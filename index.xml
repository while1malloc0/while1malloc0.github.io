<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Breaking Computer</title>
    <link>https://breaking.computer/</link>
    <description>Recent content on Breaking Computer</description>
    <generator>Hugo - gohugo.io</generator>
    <language>en</language>
    <contact>while1malloc0&#43;breakingcomputer@gmail.com</contact>
    <copyright></copyright>
    
        <atom:link href="https://breaking.computer/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Navigating Technical Disagreement</title>
      <link>https://breaking.computer/posts/navigating-technical-disagreement-6-2-19/</link>
      <pubDate>Sun, 02 Jun 2019 00:00:00 +0000</pubDate>
      <author>John Turner</author>
      <guid>https://breaking.computer/posts/navigating-technical-disagreement-6-2-19/</guid>
      <description></description>
      
      <content>&lt;p&gt;In &lt;em&gt;Never Split the Difference: Negotiating As If Your Life Depended On It&lt;/em&gt;, Chris Voss writes that getting someone to say &amp;ldquo;no&amp;rdquo; is the start of a productive negotiation.
Pushing for a hard &amp;ldquo;yes&amp;rdquo; can alienate and annoy people.
&amp;ldquo;No&amp;rdquo; allows us to find hidden points of contention, and clarify what we actually want.
Hidden contention is also at the heart of many technical disagreements.
Discovering it is a powerful technique for making disagreements productive.
Getting to &amp;ldquo;no&amp;rdquo; can be effective here as well, but I prefer to find common ground.
Finding common ground means getting engineers to agree on core principles and values.
One technique for this that I’m fond of is figuring out where on the &lt;strong&gt;ladder of values&lt;/strong&gt; I agree with someone.
The ladder of values is a mental model for arguing about projects.
Each step on the ladder is the foundation for justifying the step below it.
The steps of the ladder are implementation, requirement, outcome, and goal.
Finding common ground on one rung of the ladder allows me to better argue my views on the one below it.&lt;/p&gt;

&lt;p&gt;Implementation is &amp;ldquo;lowest&amp;rdquo; level at which to argue.
It&amp;rsquo;s saying &amp;ldquo;I don&amp;rsquo;t like line 37 of the code&amp;rdquo;, or &amp;ldquo;I don&amp;rsquo;t think this design pattern is the right choice.&amp;rdquo;
This is the level at which we engineers seem to enjoy arguing.
It&amp;rsquo;s the level that&amp;rsquo;s often seen—incorrectly, in my view—as the most &amp;ldquo;technical&amp;rdquo;.
It&amp;rsquo;s important to recognize that arguing implementation implies a ranking about what&amp;rsquo;s important in the code.
The person you’re arguing with may disagree with that ranking.
If you suspect differing opinions about what to optimize for, confirm that before continuing the discussion.
Aligning on requirements transforms &amp;ldquo;the function at line 37 should be more performant&amp;rdquo; into &amp;ldquo;the function at line 37 is trading some performance for being more readable. We agreed that performance is more important”&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;../../values-ladder.png&#34; alt=&#34;values-ladder&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Requirement&lt;/strong&gt; is where you rank architectural drivers such as readability, maintainability, and performance. I believe—in the absence of any hard data—that most technical disagreements boil down to requirements. Sentences like “do we agree that readability is more important than squeezing every inch of performance from this code?” go a long way in ensuring that you’re arguing the same thing. If you both agree, great, go back to implementation details. If you disagree, you might need to agree on what outcome you’re trying to achieve, or on how the requirements contribute to that outcome.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Outcome&lt;/strong&gt; is where you discuss what the project is trying to accomplish. This level underpins the ranking order of architectural drivers. “This tool is fast enough for us to use interactively” is an outcome. Ranking performance over readability when making trade-offs might make sense in supporting it. Agreeing on what outcome we’re trying to achieve and figuring out how ranking requirements will get us there before discussing implementation has sorted roughly 95% of my technical disagreements. The last 5% have had to go up another level and argue about the goal of the project.&lt;/p&gt;

&lt;p&gt;Arguing a &lt;strong&gt;goal&lt;/strong&gt; is about whether the project is worth working on at all. If the conversation necessitates arguing goals, it’s not going to be technical for much longer: you’ll soon have to talk about business strategy. Sometimes the calculus on whether something is worth working on is straightforward. If the options are a shiny new project that will marginally improve developer productivity and an all-out yak shave that will ensure the health of your database, you should break out the shears. If the priorities are this straightforward and the other person is still arguing for the shiny project, it might be a sign that they’re overloaded on operations work. Other times prioritization can be difficult. Maybe someone disagrees with the direction of the team, or even the company. In this case, sometimes the best thing to do is acknowledge the fundamental disagreement and end the argument. Alignment is tricky, and the headspace of a technical disagreement isn’t going to help here. You can also try to get the other person to agree to discuss at lower levels with the hypothetical “if you did happen to agree with the goal of the project, what would you think?”. You should take these answers with a healthy amount of skepticism. Disagreeing with the goal of a project invariably colors your thinking about any potential implementation of it.&lt;/p&gt;

&lt;p&gt;The next time you find yourself in an intense technical disagreement, see if you can get your colleagues to common ground on the values ladder. You might be surprised by how much common ground you find, and how effective it is when you disagree with this shared context in mind.&lt;/p&gt;
</content>
      
    </item>
    
    <item>
      <title>Snippets 2/28/19: Work From Woods</title>
      <link>https://breaking.computer/posts/snippets-2-28-19/</link>
      <pubDate>Fri, 01 Mar 2019 04:24:54 +0000</pubDate>
      <author>John Turner</author>
      <guid>https://breaking.computer/posts/snippets-2-28-19/</guid>
      <description></description>
      
      <content>&lt;p&gt;&lt;strong&gt;What is this?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;At the company that I worked for prior to the one that I currently work for (which is Squarespace, for those that don&amp;rsquo;t follow me on Twitter) we had a weekly check-in called Blurbs. The idea was really cool: you would write down what you did that week, successes, things you were thinking about, etc. Some people even added music they were listening to, movies they saw recently, and other social sorts of things. At the end of the week, you&amp;rsquo;d get an email with the Blurbs of everyone that you followed (there was a Twitter-like &amp;ldquo;follow&amp;rdquo; component to it). It was a really cool way of keeping up to date with what people were doing, and more importantly for me it gave me a ritual for getting thoughts out of my head and reflecting on some of the bigger ideas of the week. I&amp;rsquo;ve been missing that a bit lately, so I&amp;rsquo;ve decided to revive it in blog form, which is to say I&amp;rsquo;m going to be writing content that would be a newsletter if I ever gained enough readers to justify writing a newsletter. I&amp;rsquo;m also planning on writing other stuff in this space, but journaling snippets is a much-missed form of writing therapy, so this blog might be mostly that. Or not, I&amp;rsquo;m not really sure yet. In any case, here&amp;rsquo;s some of what&amp;rsquo;s been in my head this week.&lt;/p&gt;

&lt;p&gt;Also, at some point said previous company was talking about open sourcing Blurbs, and if anyone from there is reading this, you really should! (They&amp;rsquo;ve open sourced &lt;a href=&#34;https://github.com/Betterment&#34;&gt;a lot of other cool things&lt;/a&gt; though).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The actual post&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What does easy-to-delete Go code look like? I read tef&amp;rsquo;s &lt;a href=&#34;https://programmingisterrible.com/post/139222674273/write-code-that-is-easy-to-delete-not-easy-to&#34;&gt;Write Code That&amp;rsquo;s Easy To Delete&lt;/a&gt; article recently, and the question of how some of those patterns, or even the easy-to-delete heuristic, can apply to Go. I&amp;rsquo;m a sucker for &amp;ldquo;what is good code&amp;rdquo; heuristic talks, and I&amp;rsquo;ve not been able to find one on this topic so I&amp;rsquo;ll probably flesh it out into a Gophercon submission.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been enjoying John Ousterhout&amp;rsquo;s book &lt;a href=&#34;https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201&#34;&gt;A Philosophy of Software Design&lt;/a&gt;. The focus on &amp;ldquo;deep&amp;rdquo; modules (that is, modules that have a simple interface but encapsulate a lot of subtle details of lower level abstractions) has lead me to do some thinking about why I&amp;rsquo;ve historically tended to favor multiplicities of small functions. I think this is because I learned a lot of my programming ideas from Ruby. In Ruby, small functions are really beneficial because they&amp;rsquo;re easier to test, and in Ruby test coverage does some of the heavy lifting that type systems do in languages like Go. But to paraphrase something I read on Twitter recently, sometimes small functions are like taking a paragraph, writing each sentence on a different index card, and trying to get a coherent picture from it. I&amp;rsquo;ve already learned to love type systems, but I still react to them with some of amount of surprise somewhere in the back of my head (&amp;ldquo;oh, the compiler will just &lt;em&gt;tell me&lt;/em&gt; when I&amp;rsquo;ve messed up! Cool&amp;rdquo;). I think this reflection is really me learning to lean into them. I still love Ruby though. Mmm, syntactic sugar.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m at the &amp;ldquo;visualizing before I go to sleep&amp;rdquo; stage of talk prep for my upcoming talk at SRECon. This is a fairly common occurrence for me any time I have to speak to more than five people with prepared remarks, and has thus far happened for both professional (giving presentations, running trainings) and social (giving remarks at my wedding) occasions. It&amp;rsquo;s not stress, at least it doesn&amp;rsquo;t feel that way; it&amp;rsquo;s more of a constant refinement of what I want to do before I commit to practicing it out loud. I do get the &amp;ldquo;butterflies in the stomach&amp;rdquo; feeling sometimes, but I learned from an excellent video by Bill Prichard (an amazing tuba player, bass player, and human) that what I&amp;rsquo;m feeling in that instant can be re-framed as excitement. I would link the video if I could ever find it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m working from a rural-ish part of Georgia this week, visiting my family. Changes of scenery are great for writing code sometimes. Being in the woods with decent internet even more so. Screaming, adorable nieces not so much, but they make the trip worth it.&lt;/p&gt;

&lt;p&gt;For the past couple of weeks I&amp;rsquo;ve been working on a rewrite of a Squarespace internal tool. The original version has served us really well, but it&amp;rsquo;s was written in Python (a language that few people on my team have much experience with, which is a problem considering that we own the tool), and makes assumptions about how our Kubernetes clusters are grouped and configured that don&amp;rsquo;t really hold anymore, so new feature development on it has been a bit slow going. The solution the team came up with was to rewrite the tool in Go (the lingua franca of the team), and focus on extensibility and better error messaging. As part of the extensibility part, the tool is supposed to have a plugin ecosystem. I formulated some abstract designs for what I thought the plugin ecosystem should look like, and then my Team Lead, Brad, made an observation: if we write the plugin API such that the system itself could be implemented in these plugins, it&amp;rsquo;ll simplify a lot of the pains involved in plugin development. Brad often says really insightful things like this, and that&amp;rsquo;s one reason I really enjoy where I work. I&amp;rsquo;ve started implementing parts of the tool as plugins, and thus far the simplifications of the mental model have been great. I might end up writing a blog post or talk about this.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s interesting how much debugging Bluetooth issues on my Pixelbook has been like debugging Real &amp;trade; systems. I was doing roughly the same amount of Googling and terminal hackery to get things to work. In the end it turns out that the issue is probably with the headphones I was trying to pair. The whole ordeal ended with a weird feeling that was simultaneously &amp;ldquo;yes, this is an awesome thing I wouldn&amp;rsquo;t have been able to do five years ago&amp;rdquo; and &amp;ldquo;I just want to listen to Meshuggah without waking up the house, why can this not just work?&amp;rdquo;. I think those are the software engineer and consumer halves of my brain arguing.&lt;/p&gt;

&lt;p&gt;A discussion came up about Go monorepos in a meeting I was in. I hold that Go is probably a better language for monorepos than most. I don&amp;rsquo;t have the inclination to elaborate on that, but I&amp;rsquo;d love to hear some success or failure stories.&lt;/p&gt;
</content>
      
    </item>
    
  </channel>
</rss>